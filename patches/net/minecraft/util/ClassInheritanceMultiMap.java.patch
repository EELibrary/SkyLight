--- ../src-base/minecraft/net/minecraft/util/ClassInheritanceMultiMap.java
+++ ../src-work/minecraft/net/minecraft/util/ClassInheritanceMultiMap.java
@@ -1,23 +1,22 @@
 package net.minecraft.util;
 
 import com.google.common.collect.Iterators;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import java.util.AbstractSet;
 import java.util.Collections;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 public class ClassInheritanceMultiMap<T> extends AbstractSet<T>
 {
-    private static final Set < Class<? >> ALL_KNOWN = Sets. < Class<? >> newHashSet();
-    private final Map < Class<?>, List<T >> map = Maps. < Class<?>, List<T >> newHashMap();
-    private final Set < Class<? >> knownKeys = Sets. < Class<? >> newIdentityHashSet();
+    // Forge: Use concurrent collection to allow creating chunks from multiple threads safely
+    private static final Set < Class<? >> ALL_KNOWN = Collections.newSetFromMap(new java.util.concurrent.ConcurrentHashMap<Class<?>, Boolean>());
+    private final Map < Class<?>, Set<T>> map =new ConcurrentHashMap<>();
+    private final Set < Class<? >> knownKeys = Collections.synchronizedSet(Sets. < Class<? >> newIdentityHashSet());
     private final Class<T> baseClass;
-    private final List<T> values = Lists.<T>newArrayList();
+    private final Set<T> values = ConcurrentHashMap.newKeySet();
 
     public ClassInheritanceMultiMap(Class<T> baseClassIn)
     {
@@ -78,15 +77,17 @@
 
     private void addForClass(T value, Class<?> parentClass)
     {
-        List<T> list = (List)this.map.get(parentClass);
+        Set<T> set1 =  this.map.get(parentClass);
 
-        if (list == null)
+        if (set1 == null)
         {
-            this.map.put(parentClass, Lists.newArrayList(value));
+            Set set = ConcurrentHashMap.newKeySet();
+            set.addAll(values);
+            this.map.put(parentClass,set);
         }
         else
         {
-            list.add(value);
+            set1.add(value);
         }
     }
 
@@ -99,9 +100,9 @@
         {
             if (oclass.isAssignableFrom(t.getClass()))
             {
-                List<T> list = (List)this.map.get(oclass);
+                Set<T> set = this.map.get(oclass);
 
-                if (list != null && list.remove(t))
+                if (set != null && set.remove(t))
                 {
                     flag = true;
                 }
@@ -122,17 +123,15 @@
         {
             public Iterator<S> iterator()
             {
-                List<T> list = (List)ClassInheritanceMultiMap.this.map.get(ClassInheritanceMultiMap.this.initializeClassLookup(clazz));
-
-                if (list == null)
-                {
-                    return Collections.<S>emptyIterator();
+                // CatServer start - Optimization from Foamfix
+                Class c = ClassInheritanceMultiMap.this.initializeClassLookup(clazz);
+                Set<T> set = ClassInheritanceMultiMap.this.map.get(c);
+                if (set == null) {
+                    return Collections.emptyIterator();
+                } else {
+                    Iterator<T> iterator = set.iterator();
+                    return clazz == c ? (Iterator<S>) iterator : Iterators.filter(iterator, clazz);
                 }
-                else
-                {
-                    Iterator<T> iterator = list.iterator();
-                    return Iterators.filter(iterator, clazz);
-                }
             }
         };
     }
