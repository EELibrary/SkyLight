--- ../src-base/minecraft/net/minecraft/entity/EntityTracker.java
+++ ../src-work/minecraft/net/minecraft/entity/EntityTracker.java
@@ -2,11 +2,12 @@
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
+
+import java.util.Collections;
 import java.util.List;
 import java.util.Set;
-import net.minecraft.crash.CrashReport;
-import net.minecraft.crash.CrashReportCategory;
-import net.minecraft.crash.ICrashReportDetail;
+import java.util.concurrent.ConcurrentHashMap;
+
 import net.minecraft.entity.boss.EntityDragon;
 import net.minecraft.entity.boss.EntityWither;
 import net.minecraft.entity.item.EntityArmorStand;
@@ -39,7 +40,6 @@
 import net.minecraft.network.play.server.SPacketEntityAttach;
 import net.minecraft.network.play.server.SPacketSetPassengers;
 import net.minecraft.util.IntHashMap;
-import net.minecraft.util.ReportedException;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.world.WorldServer;
 import net.minecraft.world.chunk.Chunk;
@@ -47,19 +47,20 @@
 import net.minecraftforge.fml.relauncher.SideOnly;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import wearblackallday.javautils.util.ThreadPool;
 
 public class EntityTracker
 {
     private static final Logger LOGGER = LogManager.getLogger();
     private final WorldServer world;
-    private final Set<EntityTrackerEntry> entries = Sets.<EntityTrackerEntry>newHashSet();
-    private final IntHashMap<EntityTrackerEntry> trackedEntityHashTable = new IntHashMap<EntityTrackerEntry>();
-    private int maxTrackingDistanceThreshold;
+    private final Set<EntityTrackerEntry> entries = ConcurrentHashMap.newKeySet();
+    public final IntHashMap<EntityTrackerEntry> trackedEntityHashTable = new IntHashMap<EntityTrackerEntry>();
+    private volatile int maxTrackingDistanceThreshold;
 
     public EntityTracker(WorldServer theWorldIn)
     {
         this.world = theWorldIn;
-        this.maxTrackingDistanceThreshold = theWorldIn.getMinecraftServer().getPlayerList().getEntityViewDistance();
+        this.maxTrackingDistanceThreshold = net.minecraft.server.management.PlayerChunkMap.getFurthestViewableBlock(theWorldIn.spigotConfig.viewDistance); // Spigot
     }
 
     public static long getPositionLong(double value)
@@ -77,6 +78,8 @@
 
     public void track(Entity entityIn)
     {
+        if (net.minecraftforge.fml.common.registry.EntityRegistry.instance().tryTrackingEntity(this, entityIn)) return;
+
         if (entityIn instanceof EntityPlayerMP)
         {
             this.track(entityIn, 512, 2);
@@ -196,7 +199,7 @@
         }
         else if (entityIn instanceof EntityAreaEffectCloud)
         {
-            this.track(entityIn, 160, Integer.MAX_VALUE, true);
+            this.track(entityIn, 160, 10 /*Integer.MAX_VALUE*/, true); // CraftBukkit
         }
         else if (entityIn instanceof EntityEnderCrystal)
         {
@@ -213,51 +216,19 @@
         this.track(entityIn, trackingRange, updateFrequency, false);
     }
 
-    public void track(Entity entityIn, int trackingRange, final int updateFrequency, boolean sendVelocityUpdates)
-    {
-        try
-        {
-            if (this.trackedEntityHashTable.containsItem(entityIn.getEntityId()))
-            {
+    public void track(Entity entityIn, int trackingRange, final int updateFrequency, boolean sendVelocityUpdates) {
+        trackingRange = org.spigotmc.TrackingRange.getEntityTrackingRange(entityIn, trackingRange); // Spigot
+        try {
+            if (this.trackedEntityHashTable.containsItem(entityIn.getEntityId())) {
                 throw new IllegalStateException("Entity is already tracked!");
             }
-
             EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entityIn, trackingRange, this.maxTrackingDistanceThreshold, updateFrequency, sendVelocityUpdates);
             this.entries.add(entitytrackerentry);
             this.trackedEntityHashTable.addKey(entityIn.getEntityId(), entitytrackerentry);
             entitytrackerentry.updatePlayerEntities(this.world.playerEntities);
+        } catch (Throwable throwable) {
+            throwable.printStackTrace();
         }
-        catch (Throwable throwable)
-        {
-            CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Adding entity to track");
-            CrashReportCategory crashreportcategory = crashreport.makeCategory("Entity To Track");
-            crashreportcategory.addCrashSection("Tracking range", trackingRange + " blocks");
-            crashreportcategory.addDetail("Update interval", new ICrashReportDetail<String>()
-            {
-                public String call() throws Exception
-                {
-                    String s = "Once per " + updateFrequency + " ticks";
-
-                    if (updateFrequency == Integer.MAX_VALUE)
-                    {
-                        s = "Maximum (" + s + ")";
-                    }
-
-                    return s;
-                }
-            });
-            entityIn.addEntityCrashInfo(crashreportcategory);
-            ((EntityTrackerEntry)this.trackedEntityHashTable.lookup(entityIn.getEntityId())).getTrackedEntity().addEntityCrashInfo(crashreport.makeCategory("Entity That Is Already Tracked"));
-
-            try
-            {
-                throw new ReportedException(crashreport);
-            }
-            catch (ReportedException reportedexception)
-            {
-                LOGGER.error("\"Silently\" catching entity tracking error.", (Throwable)reportedexception);
-            }
-        }
     }
 
     public void untrack(Entity entityIn)
@@ -272,7 +243,10 @@
             }
         }
 
-        EntityTrackerEntry entitytrackerentry1 = this.trackedEntityHashTable.removeObject(entityIn.getEntityId());
+        EntityTrackerEntry entitytrackerentry1 = null;
+        synchronized (this){
+            entitytrackerentry1 = this.trackedEntityHashTable.removeObject(entityIn.getEntityId());
+        }
 
         if (entitytrackerentry1 != null)
         {
@@ -280,38 +254,36 @@
             entitytrackerentry1.sendDestroyEntityPacketToTrackedPlayers();
         }
     }
-
+    public static final ThreadPool TRACKER_EXECUTOR = new ThreadPool();
     public void tick()
     {
-        List<EntityPlayerMP> list = Lists.<EntityPlayerMP>newArrayList();
+        List<EntityPlayerMP> list = Collections.synchronizedList(Lists.<EntityPlayerMP>newArrayList());
+        TRACKER_EXECUTOR.execute(entries, entitytrackerentry->{
+            try{
+                entitytrackerentry.updatePlayerList(this.world.playerEntities);
 
-        for (EntityTrackerEntry entitytrackerentry : this.entries)
-        {
-            entitytrackerentry.updatePlayerList(this.world.playerEntities);
-
-            if (entitytrackerentry.playerEntitiesUpdated)
-            {
-                Entity entity = entitytrackerentry.getTrackedEntity();
-
-                if (entity instanceof EntityPlayerMP)
+                if (entitytrackerentry.playerEntitiesUpdated)
                 {
-                    list.add((EntityPlayerMP)entity);
-                }
-            }
-        }
+                    Entity entity = entitytrackerentry.getTrackedEntity();
 
-        for (int i = 0; i < list.size(); ++i)
-        {
-            EntityPlayerMP entityplayermp = list.get(i);
-
-            for (EntityTrackerEntry entitytrackerentry1 : this.entries)
-            {
-                if (entitytrackerentry1.getTrackedEntity() != entityplayermp)
-                {
-                    entitytrackerentry1.updatePlayerEntity(entityplayermp);
+                    if (entity instanceof EntityPlayerMP)
+                    {
+                        list.add((EntityPlayerMP)entity);
+                    }
                 }
-            }
-        }
+            }catch (Exception e){e.printStackTrace();}
+        });
+        TRACKER_EXECUTOR.awaitCompletion();
+        TRACKER_EXECUTOR.execute(list, entityplayermp->{
+            try{
+                for (EntityTrackerEntry entitytrackerentry1 : this.entries) {
+                    if (entitytrackerentry1.getTrackedEntity() != entityplayermp) {
+                        entitytrackerentry1.updatePlayerEntity(entityplayermp);
+                    }
+                }
+            }catch (Exception e){e.printStackTrace();}
+        });
+        TRACKER_EXECUTOR.awaitCompletion();
     }
 
     public void updateVisibility(EntityPlayerMP player)
@@ -339,6 +311,25 @@
         }
     }
 
+    /* ======================================== FORGE START =====================================*/
+
+    // don't expose the EntityTrackerEntry directly so mods can't mess with the data in there as easily
+    /**
+     * Get all players tracking the given Entity. The Entity must be part of the World that this Tracker belongs to.
+     * @param entity the Entity
+     * @return all players tracking the Entity
+     */
+    public Set<? extends net.minecraft.entity.player.EntityPlayer> getTrackingPlayers(Entity entity)
+    {
+        EntityTrackerEntry entry = (EntityTrackerEntry) trackedEntityHashTable.lookup(entity.getEntityId());
+        if (entry == null)
+            return java.util.Collections.emptySet();
+        else
+            return java.util.Collections.unmodifiableSet(entry.trackingPlayers);
+    }
+
+    /* ======================================== FORGE END   =====================================*/
+
     public void sendToTrackingAndSelf(Entity entityIn, Packet<?> packetIn)
     {
         EntityTrackerEntry entitytrackerentry = this.trackedEntityHashTable.lookup(entityIn.getEntityId());
@@ -359,8 +350,8 @@
 
     public void sendLeashedEntitiesInChunk(EntityPlayerMP player, Chunk chunkIn)
     {
-        List<Entity> list = Lists.<Entity>newArrayList();
-        List<Entity> list1 = Lists.<Entity>newArrayList();
+        List<Entity> list = Collections.synchronizedList(Lists.<Entity>newArrayList());
+        List<Entity> list1 = Collections.synchronizedList(Lists.<Entity>newArrayList());
 
         for (EntityTrackerEntry entitytrackerentry : this.entries)
         {
